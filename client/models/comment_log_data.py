# coding: utf-8

"""
    fastcomments

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 0.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from client.models.repeat_comment_check_ignored_reason import RepeatCommentCheckIgnoredReason
from client.models.repeat_comment_handling_action import RepeatCommentHandlingAction
from client.models.spam_rule import SpamRule
from typing import Optional, Set
from typing_extensions import Self

class CommentLogData(BaseModel):
    """
    CommentLogData
    """ # noqa: E501
    clear_content: Optional[StrictBool] = Field(default=None, alias="clearContent")
    is_deleted_user: Optional[StrictBool] = Field(default=None, alias="isDeletedUser")
    phrase: Optional[StrictStr] = None
    bad_word: Optional[StrictStr] = Field(default=None, alias="badWord")
    word: Optional[StrictStr] = None
    locale: Optional[StrictStr] = None
    tenant_badge_id: Optional[StrictStr] = Field(default=None, alias="tenantBadgeId")
    badge_id: Optional[StrictStr] = Field(default=None, alias="badgeId")
    was_logged_in: Optional[StrictBool] = Field(default=None, alias="wasLoggedIn")
    found_user: Optional[StrictBool] = Field(default=None, alias="foundUser")
    verified: Optional[StrictBool] = None
    engine: Optional[StrictStr] = None
    engine_response: Optional[StrictStr] = Field(default=None, alias="engineResponse")
    engine_tokens: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="engineTokens")
    trust_factor: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="trustFactor")
    rule: Optional[SpamRule] = None
    user_id: Optional[StrictStr] = Field(default=None, alias="userId")
    subscribers: Optional[Union[StrictFloat, StrictInt]] = None
    notification_count: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="notificationCount")
    votes_before: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="votesBefore")
    votes_up_before: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="votesUpBefore")
    votes_down_before: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="votesDownBefore")
    votes_after: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="votesAfter")
    votes_up_after: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="votesUpAfter")
    votes_down_after: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="votesDownAfter")
    repeat_action: Optional[RepeatCommentHandlingAction] = Field(default=None, alias="repeatAction")
    reason: Optional[RepeatCommentCheckIgnoredReason] = None
    other_data: Optional[Any] = Field(default=None, alias="otherData")
    spam_before: Optional[StrictBool] = Field(default=None, alias="spamBefore")
    spam_after: Optional[StrictBool] = Field(default=None, alias="spamAfter")
    permanent_flag: Optional[StrictStr] = Field(default=None, alias="permanentFlag")
    approved_before: Optional[StrictBool] = Field(default=None, alias="approvedBefore")
    approved_after: Optional[StrictBool] = Field(default=None, alias="approvedAfter")
    reviewed_before: Optional[StrictBool] = Field(default=None, alias="reviewedBefore")
    reviewed_after: Optional[StrictBool] = Field(default=None, alias="reviewedAfter")
    text_before: Optional[StrictStr] = Field(default=None, alias="textBefore")
    text_after: Optional[StrictStr] = Field(default=None, alias="textAfter")
    expire_before: Optional[datetime] = Field(default=None, alias="expireBefore")
    expire_after: Optional[datetime] = Field(default=None, alias="expireAfter")
    flag_count_before: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="flagCountBefore")
    trust_factor_before: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="trustFactorBefore")
    trust_factor_after: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="trustFactorAfter")
    referenced_comment_id: Optional[StrictStr] = Field(default=None, alias="referencedCommentId")
    __properties: ClassVar[List[str]] = ["clearContent", "isDeletedUser", "phrase", "badWord", "word", "locale", "tenantBadgeId", "badgeId", "wasLoggedIn", "foundUser", "verified", "engine", "engineResponse", "engineTokens", "trustFactor", "rule", "userId", "subscribers", "notificationCount", "votesBefore", "votesUpBefore", "votesDownBefore", "votesAfter", "votesUpAfter", "votesDownAfter", "repeatAction", "reason", "otherData", "spamBefore", "spamAfter", "permanentFlag", "approvedBefore", "approvedAfter", "reviewedBefore", "reviewedAfter", "textBefore", "textAfter", "expireBefore", "expireAfter", "flagCountBefore", "trustFactorBefore", "trustFactorAfter", "referencedCommentId"]

    @field_validator('permanent_flag')
    def permanent_flag_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['permanent']):
            raise ValueError("must be one of enum values ('permanent')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CommentLogData from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of rule
        if self.rule:
            _dict['rule'] = self.rule.to_dict()
        # set to None if votes_before (nullable) is None
        # and model_fields_set contains the field
        if self.votes_before is None and "votes_before" in self.model_fields_set:
            _dict['votesBefore'] = None

        # set to None if votes_up_before (nullable) is None
        # and model_fields_set contains the field
        if self.votes_up_before is None and "votes_up_before" in self.model_fields_set:
            _dict['votesUpBefore'] = None

        # set to None if votes_down_before (nullable) is None
        # and model_fields_set contains the field
        if self.votes_down_before is None and "votes_down_before" in self.model_fields_set:
            _dict['votesDownBefore'] = None

        # set to None if votes_after (nullable) is None
        # and model_fields_set contains the field
        if self.votes_after is None and "votes_after" in self.model_fields_set:
            _dict['votesAfter'] = None

        # set to None if votes_up_after (nullable) is None
        # and model_fields_set contains the field
        if self.votes_up_after is None and "votes_up_after" in self.model_fields_set:
            _dict['votesUpAfter'] = None

        # set to None if votes_down_after (nullable) is None
        # and model_fields_set contains the field
        if self.votes_down_after is None and "votes_down_after" in self.model_fields_set:
            _dict['votesDownAfter'] = None

        # set to None if other_data (nullable) is None
        # and model_fields_set contains the field
        if self.other_data is None and "other_data" in self.model_fields_set:
            _dict['otherData'] = None

        # set to None if expire_before (nullable) is None
        # and model_fields_set contains the field
        if self.expire_before is None and "expire_before" in self.model_fields_set:
            _dict['expireBefore'] = None

        # set to None if expire_after (nullable) is None
        # and model_fields_set contains the field
        if self.expire_after is None and "expire_after" in self.model_fields_set:
            _dict['expireAfter'] = None

        # set to None if flag_count_before (nullable) is None
        # and model_fields_set contains the field
        if self.flag_count_before is None and "flag_count_before" in self.model_fields_set:
            _dict['flagCountBefore'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CommentLogData from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "clearContent": obj.get("clearContent"),
            "isDeletedUser": obj.get("isDeletedUser"),
            "phrase": obj.get("phrase"),
            "badWord": obj.get("badWord"),
            "word": obj.get("word"),
            "locale": obj.get("locale"),
            "tenantBadgeId": obj.get("tenantBadgeId"),
            "badgeId": obj.get("badgeId"),
            "wasLoggedIn": obj.get("wasLoggedIn"),
            "foundUser": obj.get("foundUser"),
            "verified": obj.get("verified"),
            "engine": obj.get("engine"),
            "engineResponse": obj.get("engineResponse"),
            "engineTokens": obj.get("engineTokens"),
            "trustFactor": obj.get("trustFactor"),
            "rule": SpamRule.from_dict(obj["rule"]) if obj.get("rule") is not None else None,
            "userId": obj.get("userId"),
            "subscribers": obj.get("subscribers"),
            "notificationCount": obj.get("notificationCount"),
            "votesBefore": obj.get("votesBefore"),
            "votesUpBefore": obj.get("votesUpBefore"),
            "votesDownBefore": obj.get("votesDownBefore"),
            "votesAfter": obj.get("votesAfter"),
            "votesUpAfter": obj.get("votesUpAfter"),
            "votesDownAfter": obj.get("votesDownAfter"),
            "repeatAction": obj.get("repeatAction"),
            "reason": obj.get("reason"),
            "otherData": obj.get("otherData"),
            "spamBefore": obj.get("spamBefore"),
            "spamAfter": obj.get("spamAfter"),
            "permanentFlag": obj.get("permanentFlag"),
            "approvedBefore": obj.get("approvedBefore"),
            "approvedAfter": obj.get("approvedAfter"),
            "reviewedBefore": obj.get("reviewedBefore"),
            "reviewedAfter": obj.get("reviewedAfter"),
            "textBefore": obj.get("textBefore"),
            "textAfter": obj.get("textAfter"),
            "expireBefore": obj.get("expireBefore"),
            "expireAfter": obj.get("expireAfter"),
            "flagCountBefore": obj.get("flagCountBefore"),
            "trustFactorBefore": obj.get("trustFactorBefore"),
            "trustFactorAfter": obj.get("trustFactorAfter"),
            "referencedCommentId": obj.get("referencedCommentId")
        })
        return _obj


